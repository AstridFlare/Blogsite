var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// external dependencies
import React, { Component, PureComponent } from 'react';

// utils
import { getComponentDisplayName, setLifecycleMethods } from './utils';

/**
 * @function getClassHoc
 *
 * @description
 * for class-based components, use inheritance inversion to retain state, overriding the lifecycle methods
 *
 * @param {ReactComponent} PassedComponent the component to wrap in an HOC
 * @param {Object} methods the methods to apply to the HOC
 * @param {Object} options the options for customizing implementation
 * @param {boolean} options.injectProps should the props be injected into the lifecycle methods
 * @returns {ReactComponent} HOC inheriting from PassedComponent with lifecycle methods
 */
export var getClassHoc = function getClassHoc(PassedComponent, methods, _ref) {
  var _class, _temp;

  var injectProps = _ref.injectProps;

  var displayName = getComponentDisplayName(PassedComponent);

  return _temp = _class = function (_PassedComponent) {
    _inherits(PureLifecycleClass, _PassedComponent);

    function PureLifecycleClass() {
      _classCallCheck(this, PureLifecycleClass);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      var _this = _possibleConstructorReturn(this, _PassedComponent.call.apply(_PassedComponent, [this].concat(args)));

      setLifecycleMethods(_this, methods, injectProps);
      return _this;
    }

    PureLifecycleClass.prototype.render = function render() {
      return _PassedComponent.prototype.render.call(this);
    };

    return PureLifecycleClass;
  }(PassedComponent), _class.displayName = displayName, _temp;
};

/**
 * @function getFunctionHoc
 *
 * @description
 * for function-based components, use a props proxy wrapper and add the lifecycle methods
 *
 * @param {ReactComponent} PassedComponent the component to wrap in an HOC
 * @param {Object} passedMethods the methods to apply to the HOC
 * @param {Object} options the options for customizing implementation
 * @param {boolean} options.injectProps should the props be injected into the lifecycle methods
 * @param {boolean} options.usePureComponent should the HOC be a PureComponent
 * @returns {ReactComponent} HOC wrapping PassedComponent with lifecycle methods
 */
export var getFunctionHoc = function getFunctionHoc(PassedComponent, passedMethods, _ref2) {
  var _class2, _temp2;

  var injectProps = _ref2.injectProps,
      usePureComponent = _ref2.usePureComponent;

  var ComponentToExtend = usePureComponent ? PureComponent : Component;
  var displayName = getComponentDisplayName(PassedComponent);

  var methods = _extends({}, passedMethods);
  var childContextTypes = PassedComponent.childContextTypes ? _extends({}, PassedComponent.childContextTypes) : undefined;

  if (childContextTypes) {
    // eslint-disable-next-line no-param-reassign
    delete PassedComponent.childContextTypes;
  }

  return _temp2 = _class2 = function (_ComponentToExtend) {
    _inherits(PureLifecycleFunctional, _ComponentToExtend);

    function PureLifecycleFunctional() {
      _classCallCheck(this, PureLifecycleFunctional);

      for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
        args[_key2] = arguments[_key2];
      }

      var _this2 = _possibleConstructorReturn(this, _ComponentToExtend.call.apply(_ComponentToExtend, [this].concat(args)));

      setLifecycleMethods(_this2, methods, injectProps);
      return _this2;
    }

    PureLifecycleFunctional.prototype.render = function render() {
      return React.createElement(PassedComponent, this.props);
    };

    return PureLifecycleFunctional;
  }(ComponentToExtend), _class2.displayName = displayName, _class2.propTypes = PassedComponent.propTypes, _class2.defaultProps = PassedComponent.defaultProps, _class2.contextTypes = PassedComponent.contextTypes, _class2.childContextTypes = childContextTypes, _temp2;
};